import lara.utils.Utils;
import clava.ClavaJoinPoints;

import weaver.Query;

var Transformations = {};

/**
* Limitations: Only works for loops with 3 nesting levels - can be worked around by looking at the 3 innermost loops.
*/
Transformations.loopFission = function(log) {
	log = log || false;
	for(var chain of Query.search("function", {name: "imsmooth"}).search("loop", {kind: "for"}).scope("loop", {kind: "for"}).scope("loop", {kind: "for", isInnermost: true}).chain()) {	
		var iterators = [chain["loop_0"].controlVar, chain["loop_1"].controlVar, chain["loop_2"].controlVar];
		var exclusiveLoopStatements = Utils.getExclusiveLoopStatements(chain["loop_1"], chain["loop_2"]);
		//If the intermediate loop has dependencies on more than one iterator, this transformation cannot be applied.
		try {
			var it = Utils.getDirectionIterator(exclusiveLoopStatements, iterators);
		}
		catch(err) {
			println(err);
			continue;
		}
				
		var outerLoop = chain["loop_0"];
	
		if(log) println("Creating copies of outer loop.");
		// Create 3 copies of the outer loop
		var outerLoops = [
			outerLoop.copy(),
			outerLoop.copy(),
			outerLoop.copy()
		];
		if(log) println("Getting copies of medium loops.");
		// Get the medium loop of each copy (which's body we will manipulate)
		var mediumLoops = [
			outerLoops[0].descendants("loop")[0],
			outerLoops[1].descendants("loop")[0], 
			outerLoops[2].descendants("loop")[0]
		];
		if(log) println("Getting body copies of medium loops.");
		// Get the body of each medium Loop
		var bodies = [
			mediumLoops[0].body,
			mediumLoops[1].body,
			mediumLoops[2].body
		];
	
		// If the iterating loop is the outermost, we will change the outerLoops
		// If the iterating loop is the medium, we will change the mediumLoops
		
		if(log) println("Getting copies of inner loops.");
		// Create 3 copies of the inner loop
		var innerLoops = [
			outerLoops[0].descendants("loop")[1],
			outerLoops[1].descendants("loop")[1],
			outerLoops[2].descendants("loop")[1]
		];
	
		if(log) println("Setting iterating loops as copy of outer or medium loops.");
		itLoops = outerLoop.controlVar === it ? outerLoops : mediumLoops;
		
			
		/****** Unused for now ******
		
		// And respective bodies
		var innerBodies = [
			innerLoops[0].body,
			innerLoops[1].body,
			innerLoops[2].body,
		];
		
		// Assumes increments of 1
		var stepExpression = "++" + itLoop.stepValue;
		
		var controlVar = itLoop.controlVar;
		var condRelation = itLoop.condRelation;	
		
		var startInflex_1 = "0";
		var startInflex_2 = "i-W";
		var endInflex_1 = "i+W";
		var endInflex_2 = "N-1";
		/****************************/
		
		var startNode_1 = "0";
		var startNode_2 = it +"-W";
		
		var endNode_1 = it + "+W";
		var endNode_2 = "N-1";
		
		var filterNode_1 = ClavaJoinPoints.stmtLiteral("int filterStart = W-" + it + ";");
		var filterNode_2 = ClavaJoinPoints.stmtLiteral("int filterStart = 0;");
	
		if(log) println("Creating first loop.");
		var init_1 = "0";
		var end_1 = "W";
		itLoops[0].setInitValue(init_1);
		itLoops[0].setEndValue(end_1);
		//var cond_1 = Utils.getCondExpression(controlVar, condRelation, loop_1.endValue);
		innerLoops[0].setInitValue(startNode_1);
		innerLoops[0].setEndValue(endNode_1);
		bodies[0].stmts[0].detach();
		bodies[0].stmts[0].detach();
		bodies[0].stmts[0].replaceWith(filterNode_1);
		
		if(log) println("Creating second loop.");
		var init_2 = "W";
		var end_2 = "N-W-1";
		itLoops[1].setInitValue(init_2);
		itLoops[1].setEndValue(end_2);
		//var cond_2 = Utils.getCondExpression(controlVar, condRelation, loop_3.endValue);
		innerLoops[1].setInitValue(startNode_2);
		innerLoops[1].setEndValue(endNode_1);
		bodies[1].stmts[0].detach();
		bodies[1].stmts[0].detach();
		bodies[1].stmts[0].replaceWith(filterNode_2);
		
		if(log) println("Creating third loop.");
		var init_3 = "N-W-1";
		var end_3 = "N";
		itLoops[2].setInitValue(init_3);
		itLoops[2].setEndValue(end_3);
		//var cond_3 = Utils.getCondExpression(controlVar, condRelation, loop_3.endValue);
		innerLoops[2].setInitValue(startNode_2);
		innerLoops[2].setEndValue(endNode_2);
		bodies[2].stmts[0].detach();
		bodies[2].stmts[0].detach();
		bodies[2].stmts[0].replaceWith(filterNode_2);
	
		if(log) println("Replacing original loop with 3 modified loops.");
		outerLoop.insertAfter(outerLoops[2]);
		outerLoop.insertAfter(outerLoops[1]);
		outerLoop.replaceWith(outerLoops[0]);

	}

	if(log) {
		var imsmooth = Query.search("function", {name: "imsmooth"}).first();
		println(imsmooth.code);
	}
}


/** 
* Replace literal double arguments in float returning calls with a literal float argument.
* Example: '0.5' is replaced by '0.5f' if it's an argument of a float returning method.
* Limitations: doubles with lots of significant digits are also turned into floats, which
*			may cause	loss of information, distortion, or other issues.
*			These limitations do not express themselves in the Vision benchmarks.
* @author {Nuno Gomes}
*/
Transformations.replaceDoublesWithFloats =  function(log) {
	log = log || false;
	if(log) println("Replacing doubles.");
	var count = 0;
	var functions = [];
	for(var $call of Query.search("call")) {
		//if($call.type.code === "double")
			//continue;
		for(var argument of $call.args) {
			if(argument.type.code !== "double")
				continue;
			for(var expression of argument.descendants) {
				if(expression.type.code === "double" && expression.descendants.length === 0) {
					if(log) println("Replacing double "+ expression.code + " for float " + expression.code + 
							"f in " + $call.code + " of type " + $call.type.code + ".");
					if(!functions.includes($call.ancestor("file").name)) {
						functions.push($call.ancestor("file").name);
						$call.ancestor("file").addGlobal(dFCount, ClavaJoinPoints.builtinType("int"), "0");
					}
					$call.ancestor("statement").insertBefore(dFCount + "++;");
					expression.replaceWith(expression.code + "f");
					count++;
				}
			}
		}
	}
	if(log) {
		println(functions);
		println("Number of doubles replaced with floats: " + count);
	}
}

/** 
* Replace every call of the function pow(k, n), with:
* k * (... n times ...) * k, when n >= 2
* k, when n = 1
* 1, when n = 0
* Limitations: negative values of n
* @author {Tiago Lascasas}
*/
Transformations.replacePowCalls =  function(log) {
	log = log || false;
	if(log) println("Replacing 'pow()' calls.");
	var changes = true;
	var count = 0;	
	var functions = [];
	while(changes) {
		changes = false;
		for(var $call of Query.search("call", {name: "pow"})) {
			// If power is not a literal integer, no change is supported
			if (!($call.args[1].type === "int" || /[0-9]\d*/.test($call.args[1].code)))
				continue;
			var power = parseInt($call.args[1].code);
			var expression = ClavaJoinPoints.parenthesis($call.args[0]);
			if(power >= 2) {
				// Store first 2 multiplication operands in node
				node = ClavaJoinPoints.binaryOp("mul", expression.copy(), expression.copy(), $call.args[0].type);
				// Store the rest of the multiplication operands in node
				// Stop after power is reached
				for (var i = 3; i <= power; i++) {
					node = ClavaJoinPoints.binaryOp("mul", expression.copy(), node, $call.args[0].type);
				}
				// Introduce global variable in file
				if(!functions.includes($call.ancestor("file").name)) {
					functions.push($call.ancestor("file").name);
					$call.ancestor("file").addGlobal(powCount, ClavaJoinPoints.builtinType("int"), "0");
				}
				// Add 1 execution counter incrementation
				$call.ancestor("statement").insertBefore(powCount + "++;");

				// Wrap new node in parenthesis to guarantee arithmetic consistency
				node = ClavaJoinPoints.parenthesis(node);
				
				$call.replaceWith(node);
				changes = true;
				count++;
			}
			else if (power == 1) {
				// Introduce global variable in file
				if(!functions.includes($call.ancestor("file").name)) {
					functions.push($call.ancestor("file").name);
					$call.ancestor("file").addGlobal(powCount, ClavaJoinPoints.builtinType("int"), "0");
				}
				// Add 1 execution counter incrementation
				$call.ancestor("statement").insertBefore(powCount + "++;");
				
				$call.replaceWith(expression);
				changes = true;
				count++;
			}
			else if (power == 0) {
				// Introduce global variable in file
				if(!functions.includes($call.ancestor("file").name)) {
					functions.push($call.ancestor("file").name);
					$call.ancestor("file").addGlobal(powCount, ClavaJoinPoints.builtinType("int"), "0");
				}
				// Add 1 execution counter incrementation
				$call.ancestor("statement").insertBefore(powCount + "++;");
				$call.replaceWith(ClavaJoinPoints.integerLiteral(1));
				changes = true;
				count++;
			}
			// Negative exponents are not supported, yet
		}
	}
	if(log) {
		println(functions);
		println("Number of pow() calls replaced: " + count);
	}
}
	
	/**** CREATE LOOP PARAMETER STATEMENTS *****/
	
	/******************************************/
	//ClavaJoinPoints.forStmt(loopChain["loop_2"].init, condExpression, stepExpression, loopChain["loop_2"].body);

	/*

     	dLoop = [Loop que itera sobre a variavel direction];
     	endValue = dLoop.endValue;
     	startValue = dLoop.startValue;
     	
     	dLoopStart_0 = startValue;
     	dLoopEnd_0 = W;
     	
     	start_0 = 0						(<=> dLoopStart_0)
     	end_0 = direction+W					(<=> direction + dLoopEnd_0)
     	filter_0 = W-direction				(<=> dLoopEnd_0 + direction)

     	
     	dLoopStart_1 = W					(<=> dLoopEnd_0)
     	dLoopEnd_1 = endValue-W-1;
     	
     	start_1 = direction-W				(<=> direction - dLoopStart_1)
     	end_1 = direction+W					(<=> direction + dLoopStart_1)
     	filter_1 = 0						(<=> dLoopStart_0)

     	
     	dLoopStart_2 = endValue-W-1;			(<=> dLoopEnd_1)
     	dLoopEnd_2 = endValue;
     	
     	start_2 = direction-W				(<=> direction - dLoopStart_1)
     	end_2 = endValue-1					(<=> dLoopEnd_2 - 1)
     	filter_2 = 0						(<=> dLoopStart_0)

		for(j = 0 ; j < M ; ++j) 
		{
     		for(i = 0 ; i < N ; ++i) 
			{
        			int startCol = MAX(i-W,0);
        			int endCol = MIN(i+W, N-1);
        			int filterStart = MAX(0, W-i);
        			for(k=startCol; k<=endCol; k++)
            			subsref(buffer,j,i) += subsref(array, j, k) * temp[filterStart++];
 			}
   	 	}
   	 	
		for(j = 0; j < W; ++j)
			for(i = 0; i < N; ++i)
     	     	for(k=0; k<=j+W; k++)
					subsref(out,j,i) += subsref(buffer,k,i) * temp[k+W-j]; (SUBSTITUIDO PELA MACRO)
     	 //Valores interiores da matriz
     	 for(j = W; j < M-W-1; ++j)
     	 	for(i = 0; i < N; ++i)
     	     	for(k=0; k<=2*W; k++)
     	         		subsref(out,j,i) += subsref(buffer,k+j-W,i) * temp[k]; (SUBSTITUIDO PELA MACRO)
     	 //Moldura inferior
	 	 for(j = M-W-1; j < M; ++j)
     	 	for(i = 0; i < N; ++i)
     	     	for(k=0; k<=M+W-j-1; k++)
     	     	    subsref(out,j,i) += subsref(buffer,k+j-W,i) * temp[k]; (SUBSTITUIDO PELA MACRO)
	*/
