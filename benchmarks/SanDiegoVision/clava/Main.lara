import lara.benchmark.SDVBSBenchmarkSet;
import lara.benchmark.BenchmarkSet;
import lara.code.Timer;

import lara.utils.Utils;

import clava.ClavaJoinPoints;
import clava.gprofer.Gprofer;

import weaver.Query;
import lara.code.Logger;

var powCount = "powCount";
var dFCount = "dFCount";

aspectdef Main	
	
setDebug(!true);
var benchmarkNames = ["sift"];
for(var benchmarkName of benchmarkNames) {
	for(var benchmark of setupSanDiego(benchmarkName, ["FullHD"])) {
		
		var mainFunction = Query.search("function", { name: "main" }).first();
		var mainFile = mainFunction.ancestor("file");
		mainFile.addGlobal(powCount, ClavaJoinPoints.builtinType("int"), "0");
		mainFile.addGlobal(dFCount, ClavaJoinPoints.builtinType("int"), "0");
		var loggerPow = new Logger();
		var loggerDF = new Logger();
		
		Utils.removeMethodCalls([
			"assert", 
			//"photonReportTiming", 
			//"photonPrintTiming", 
			//"photonStartTiming", 
			//"photonEndTiming",
			"printf"
		]);
		//
		var logLocation = mainFunction.descendants("statement")[mainFunction.descendants("statement").length-2];
		loggerPow.text("  Pow calls: ").int("powCount");
		loggerPow.logBefore(logLocation);
		
		loggerDF.text("  Floats that were previously doubles were used these many times: ").int("dFCount");
		loggerDF.logBefore(logLocation);
		//*/
		Utils.timeMethodCalls(benchmarkName);
		
		replaceDoublesWithFloats();
		replacePowCalls();
		// loopSearch();
		
		benchmark.compile();
		//for(var i = 0; i < 10; i++)

		var execution = benchmark.execute();
		println(execution.getReturnValue());
	}
}
end


function setupSanDiego(benchmarkNames, inputSizes) {
	var sdvbs = new SDVBSBenchmarkSet();
	sdvbs.setInputSizes(inputSizes);
	sdvbs.setBenchmarks(benchmarkNames);
	
	return sdvbs;
}

/**
* Limitations: Only works for loops with 3 nesting levels - can be worked around by looking at the 3 innermost loops.
*/
function loopSearch() {
	for(var chain of Query.search("function", {name: "imsmooth"}).search("loop", {kind: "for"}).scope("loop", {kind: "for"}).scope("loop", {kind: "for", isInnermost: true}).chain()) {
		var direction = Utils.getDirectionIterator(chain);
		//If the intermediate loop has dependencies on more than one iterator, this transformation cannot be applied.
		if(!direction) continue;
		var condExpression = Utils.getCondExpression(chain["loop_0"].controlVar, chain["loop_0"].condRelation.toString(), chain["loop_0"].endValue);
		
		println(typeof chain["loop_0"].stepValue);
		switch(chain["loop_0"].stepValue) {
			case "1":
				var stepExpression = "++" + chain["loop_0"].controlVar;
				break;
			case "-1":
				var stepExpression = "--" + chain["loop_0"].controlVar;
				break;
			default:
				var stepExpression = chain["loop_0"].controlVar + " = " + chain["loop_0"].controlVar + " + " + chain["loop_0"].stepValue;
		}
		var expression = ClavaJoinPoints.forStmt(chain["loop_0"].init, condExpression, stepExpression, chain["loop_0"].body);
		println(expression.code);

		println("\n\n");

	/* PSEUDO CODIGO

	1. Construir os 3 loops - parametros base, ainda que errados

	2. Alterar os parametros dos loops - Referencia abaixo, devera ser preciso fazer rebuild da AST
	2.1. VAR node = (
      	//Moldura superior
		for(j = 0; j < W; ++j)
			for(i = 0; i < N; ++i)
     	     	for(k=0; k<=j+W; k++)
					subsref(out,j,i) += subsref(buffer,k,i) * temp[k+W-j]; (SUBSTITUIDO PELA MACRO)
     	 //Valores interiores da matriz
     	 for(j = W; j < M-W-1; ++j)
     	 	for(i = 0; i < N; ++i)
     	     	for(k=0; k<=2*W; k++)
     	         		subsref(out,j,i) += subsref(buffer,k+j-W,i) * temp[k]; (SUBSTITUIDO PELA MACRO)
     	 //Moldura inferior
	 	 for(j = M-W-1; j < M; ++j)
     	 	for(i = 0; i < N; ++i)
     	     	for(k=0; k<=M+W-j-1; k++)
     	     	    subsref(out,j,i) += subsref(buffer,k+j-W,i) * temp[k]; (SUBSTITUIDO PELA MACRO)
	)
	loop_0.replaceWith(node)
	
	*/
	}
}

/** 
* Replace literal double arguments in float returning calls with a literal float argument.
* Example: '0.5' is replaced by '0.5f' if it's an argument of a float returning method.
* Limitations: doubles with lots of significant digits are also turned into floats, which
*			may cause	loss of information, distortion, or other issues.
*			These limitations do not express themselves in the Vision benchmarks.
* @author {Nuno Gomes}
*/
function replaceDoublesWithFloats() {
	println("Replacing doubles.");
	var count = 0;
	var functions = [];
	for(var $call of Query.search("call")) {
		//if($call.type.code === "double")
			//continue;
		for(var argument of $call.args) {
			if(argument.type.code !== "double")
				continue;
			for(var expression of argument.descendants) {
				if(expression.type.code === "double" && expression.descendants.length === 0) {
					//println("Replacing double "+ expression.code + " for float " + expression.code + 
					//		"f in " + $call.code + " of type " + $call.type.code + ".");
					if(!functions.includes($call.ancestor("file").name)) {
						functions.push($call.ancestor("file").name);
						$call.ancestor("file").addGlobal(dFCount, ClavaJoinPoints.builtinType("int"), "0");
					}
					$call.ancestor("statement").insertBefore(dFCount + "++;");
					expression.replaceWith(expression.code + "f");
					count++;
				}
			}
		}
	}
	println(functions);
	println("Number of doubles replaced with floats: " + count);
}

/** 
* Replace every call of the function pow(k, n), with:
* k * (... n times ...) * k, when n >= 2
* k, when n = 1
* 1, when n = 0
* Limitations: negative values of n
* @author {Tiago Lascasas}
*/
function replacePowCalls() {
	println("Replacing 'pow()' calls.");
	var changes = true;
	var count = 0;	
	var functions = [];
	while(changes) {
		changes = false;
		for(var $call of Query.search("call", {name: "pow"})) {
			if (!($call.args[1].type === "int" || /[0-9]\d*/.test($call.args[1].code)))
				continue;
			var power = parseInt($call.args[1].code);
			var expression = ClavaJoinPoints.parenthesis($call.args[0]);
			if(power >= 2) {
				node = ClavaJoinPoints.binaryOp("mul", expression.copy(), expression.copy(), $call.args[0].type);
				for (var i = 3; i <= power; i++) {
					node = ClavaJoinPoints.binaryOp("mul", expression.copy(), node, $call.args[0].type);
				}
				if(!functions.includes($call.ancestor("file").name)) {
					functions.push($call.ancestor("file").name);
					$call.ancestor("file").addGlobal(powCount, ClavaJoinPoints.builtinType("int"), "0");
				}
				$call.ancestor("statement").insertBefore(powCount + "++;");

				// Wrap my node in parenthesis in case it is part of a denominator
				node = ClavaJoinPoints.parenthesis(node);
				
				$call.replaceWith(node);
				changes = true;
				count++;
			}
			else if (power == 1) {
				if(!functions.includes($call.ancestor("file").name)) {
					functions.push($call.ancestor("file").name);
					$call.ancestor("file").addGlobal(powCount, ClavaJoinPoints.builtinType("int"), "0");
				}
				$call.ancestor("statement").insertBefore(powCount + "++;");
				$call.replaceWith(expression);
				changes = true;
				count++;
			}
			else if (power == 0) {
				if(!functions.includes($call.ancestor("file").name)) {
					functions.push($call.ancestor("file").name);
					$call.ancestor("file").addGlobal(powCount, ClavaJoinPoints.builtinType("int"), "0");
				}
				$call.ancestor("statement").insertBefore(powCount + "++;");
				$call.replaceWith(ClavaJoinPoints.integerLiteral(1));
				changes = true;
				count++;
			}
		}
	}
	println(functions);
	println("Number of pow() calls replaced: " + count);
}